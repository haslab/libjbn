/*
   GENERIC CODE (parametric on the number of limbs)

   Name Conventions:
     _* <- internal (non-exported) jasmin functions
     *_ <- inlined functions
*/

#ifndef JASMIN_BN_GENERIC
#define JASMIN_BN_GENERIC


// default values...
#ifndef NLIMBS
param int nlimbs;
#define NLIMBS
#endif

/* Loads BN from memory
 */
inline fn _bn_load_
( reg u64 a
) -> stack u64[nlimbs]
{
  inline int i;
  stack u64[nlimbs] x;
  reg u64 t;

  for i = 0 to nlimbs {
    t = [a + 8*i];
    x[i] = t;
  }

  return x;
}

/* Stores a BN into memory */
inline fn _bn_store_
( reg u64 a,
  reg ptr u64[nlimbs] b
)
{
  inline int i;
  reg u64 t;

  for i = 0 to nlimbs {
    t = b[i];
    [a + 8*i] = t;
  }
}

/* Loads a double BN from memory
 */
inline fn _bn2_load_
( reg u64 a
) -> stack u64[2*nlimbs]
{
  inline int i;
  stack u64[2*nlimbs] x;
  reg u64 t;

  for i = 0 to 2*nlimbs {
    t = [a + 8*i];
    x[i] = t;
  }

  return x;
}

/* Stores a double BN into memory */
inline fn _bn2_store_
( reg u64 a,
  reg ptr u64[2*nlimbs] b
)
{
  inline int i;
  reg u64 t;

  for i = 0 to 2*nlimbs {
    t = b[i];
    [a + 8*i] = t;
  }
}

/* unpack a double BN into two BNs */
inline fn _bn2_unpack_
( reg ptr u64[2*nlimbs] a
) -> stack u64[nlimbs], stack u64[nlimbs]
{
  inline int i;
  stack u64[nlimbs] hi lo;
  reg u64 t1 t2;

  for i = 0 to nlimbs {
    t1 = a[i];
    t2 = a[nlimbs + i];
    lo[i] = t1;
    hi[i] = t2;
  }

  return hi, lo;
}

/* pack two bignums into a double bignum */
inline fn _bn_pack2_
( reg ptr u64[nlimbs] lo hi
) -> stack u64[2*nlimbs]
{
  inline int i;
  stack u64[2*nlimbs] r;
  reg u64 t;

  for i = 0 to nlimbs {
    t = lo[i];
    r[i] = t;
  }
  for i = 0 to nlimbs {
    t = hi[i];
    r[nlimbs+i] = t;
  }

  return r;
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn _bn_eq_
( reg ptr u64[nlimbs] a b
) -> reg u64 /* 0 or 1 */ {
  inline int i;
  reg u64 acc are_equal t res;
  reg bool zf;

  res = 0;
  are_equal = 1;
  acc = 0;
  for i = 0 to nlimbs {
    t = a[i];
    t ^= b[i];
    acc |= t;
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
  res = are_equal if zf;
    
  return res;
}

fn _bn_eq
( reg ptr u64[nlimbs] a b
) -> reg u64 /* 0 or 1 */ {
  reg u64 r;
  r = _bn_eq_(a,b);
  return r;
}

/**
 * Checks if a bignum is zero.
 * If a == 0, return 1. Otherwise, return 0.
 */
inline fn _bn_test0_
( reg ptr u64[nlimbs] a) -> reg u64 {
  inline int i;
  reg u64 acc is_zero res;
  reg bool zf;

  res = 0;
  is_zero = 1;    
  acc = a[0];
  for i = 1 to nlimbs {
    acc |= a[i];
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
  res = is_zero if zf;

  return res;
}

fn _bn_test0
( reg ptr u64[nlimbs] a
) -> reg u64 /* 0 or 1 */ {
  reg u64 r;
  r = _bn_test0_(a);
  return r;
}

/* copy a BN */
inline fn _bn_copy_
( reg ptr u64[nlimbs] a
) -> stack u64[nlimbs] {
  inline int i;
  reg u64 t;
  stack u64[nlimbs] r;
    
  for i = 0 to nlimbs {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

inline fn _bn_copy2_
( reg ptr u64[nlimbs] a r
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
    
  for i = 0 to nlimbs {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

/* conditional move bignum [b] into [a] "cond ? b : a" */
inline fn _bn_cmov_
( reg bool cond
, reg ptr u64[nlimbs] a b
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
    
  for i = 0 to nlimbs {
    t = a[i];
    t = b[i] if cond;
    a[i] = t;
  }
    
  return a;
}

/* zeroing a BN */
inline fn _bn_set0_
( reg ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  t = 0;
  for i = 0 to nlimbs {
    a[i] = t;
  }
  return a;
}

/* add a digit and propagate carry */
inline fn _bn_add1c_
( reg ptr u64[nlimbs] a,
  reg u64 b
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg bool cf;

  cf, a[0] += b;
  for i=1 to nlimbs
  { cf, a[i] += 0 + cf; }

  return cf, a;
}

/* multi-limb addition */
inline fn _bn_addc_
( reg ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] += t;
  for i=1 to nlimbs { 
   t = b[i];
   cf, a[i] += t + cf;
  }

  return cf, a;
}

/* Non-inlined version */
fn _bn_addc
( reg ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs]
{
  reg bool cf;
  cf, a = _bn_addc_(a, b);
  return cf, a;
}

/* performs multi-limb subtraction */
inline fn _bn_subc_
( reg ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] -= t;
  for i=1 to nlimbs {
   t = b[i];
   cf, a[i] -= t - cf;
  }

  return cf, a;
}

/* Non-inlined version */
fn _bn_subc
( reg ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs]
{
  reg bool cf;
  cf, a = _bn_subc_(a, b);
  return cf, a;
}

/** 
  * MULTIPLICATION: product-scanning
  */

// ACCUMULATOR
inline fn _addacc3_
( reg u64 b1 b0
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += 0 + cf;
  return a;
}

inline fn _muln_innerloop_
( inline int k istart iend
, reg ptr u64[nlimbs] a b
, reg u64[3] x
) -> reg u64[3] {
  reg u64 t1, t0;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    t0 = a[i];
    t1, t0 = t0 * b[j];
    x = _addacc3_(t1, t0, x, k);
  }
  return x;
}

inline fn _bn_muln_
( reg ptr u64[nlimbs] a b
, reg ptr u64[2*nlimbs] r
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;


  t0 = a[0];
  t1, t0 = t0 * b[0];
  r[0] = t0;
  x[1] = t1;
  _, _, _, _, _, x[2] = #set0();
  _, _, _, _, _, x[0] = #set0();
  for k = 1 to nlimbs {
    x = _muln_innerloop_(k, 0, k+1, a, b, x);
    t0 = x[k % 3];
    _, _, _, _, _, x[k % 3] = #set0();
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = _muln_innerloop_(k, k-nlimbs+1, nlimbs, a, b, x);
    t0 = x[k % 3];
    _, _, _, _, _, x[k % 3] = #set0();
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

fn _bn_muln
( reg ptr u64[nlimbs] a b
, reg ptr u64[2*nlimbs] r
) -> reg ptr u64[2*nlimbs] {
  r = _bn_muln_(a, b, r);
  return r;
}


/* obs: yet another instance of the innerloop, when
 both parameters are equal */
/*
BENCH: j_fp_exp_low2                    = 105892,107110,108524
BENCH: j_fp_exp_low                     = 112564,113720,114904
BENCH:   fp_exp                         = 110964,111532,112152
*/
/*
inline fn _addacc3x2_
( reg u64 x y
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  reg u64 b2, b1, b0;
  b1, b0 = x * y;
  _, _, _, _, _, b2 = #set0();

  _, cf, _, _, _, b0 = #SHL(b0, 1);
  _, cf, b1 = #RCL(b1, 1, cf);

  cf, b2 += b2 + cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += b2 + cf;
  return a;
}
*/
/*
BENCH: j_fp_exp_low2                    = 103628,104758,105930
BENCH: j_fp_exp_low                     = 112202,113378,114598
BENCH:   fp_exp                         = 110860,111444,112062
*/
inline fn _addacc3x2_
( reg u64 x y
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  reg u64 t b2 b1 b0;

  b1, b0 = x * y;

  t = b0; 
  b0 <<= 1;
  _, cf, _, _, _, b1 = #SHLD(b1, t, 1);

  b2 = #MOV(0);
  cf, b2 += b2 + cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += b2 + cf;
  return a;
}

inline fn _sqrn_innerloop_
( inline int k istart iend
, reg ptr u64[nlimbs] a
, reg u64[3] x
) -> reg u64[3] {
  reg u64 ti, tj;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    ti = a[i];
    tj = a[j];
    x = _addacc3x2_(ti, tj, x, k);
  }
  return x;
}

inline fn _bn_sqrn_
( reg ptr u64[nlimbs] a
, reg ptr u64[2*nlimbs] r
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;

  t0 = a[0];
  t1, t0 = t0 * t0;
  r[0] = t0;
  x[1] = t1;
  _, _, _, _, _, x[2] = #set0();
  _, _, _, _, _, x[0] = #set0();

  for k = 1 to nlimbs {
    x = _sqrn_innerloop_(k, 0, (k+1)/2, a, x);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = _addacc3_(t1, t0, x, k);
    }
    t0 = x[k % 3];
    _, _, _, _, _, x[k % 3] = #set0();
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = _sqrn_innerloop_(k, k-nlimbs+1, (k+1)/2, a, x);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = _addacc3_(t1, t0, x, k);
    }
    t0 = x[k % 3];
    _, _, _, _, _, x[k % 3] = #set0();
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

fn _bn_sqrn
( reg ptr u64[nlimbs] a
, reg ptr u64[2*nlimbs] r
) -> reg ptr u64[2*nlimbs] {
  r = _bn_sqrn_(a, r);
  return r;
}



#ifdef BN_GENERIC_EXPORT

/* exported version 
 remark: really like to have support for [reg ptr] in
 exported functions :-)...
*/

export fn bn_eq(reg u64 ap bp) -> reg u64 {
 stack u64[nlimbs] a b;
 reg u64 r;
 a = _bn_load_(ap);
 b = _bn_load_(bp);
 r = _bn_eq_(a, b);
 return r;
}
  
export fn bn_test0(reg u64 ap) -> reg u64 {
 stack u64[nlimbs] a;
 reg u64 r;
 a = _bn_load_(ap);
 r = _bn_test0_(a);
 return r;
}
  
export fn bn_copy(reg u64 rp ap) {
  inline int i;
  reg u64 t;
   
  for i = 0 to nlimbs {
    t = [ap + 8*i];
    [rp + 8*i] = t;
  }
}

export fn bn_set0(reg u64 rp) {
  inline int i;
  for i = 0 to nlimbs {
    [rp + 8*i] = 0;
  }
}
  
export fn bn_addn(reg u64 rp ap bp) {
 reg bool _cf;
 stack u64[nlimbs] a, b;
 reg ptr u64[nlimbs] r;
 a = _bn_load_(ap);
 b = _bn_load_(bp);
 _cf, r = _bn_addc_(a, b);
 _bn_store_(rp, r);
}

export fn bn_subn
( reg u64 rp ap bp
) {
 reg bool _cf;
 stack u64[nlimbs] a, b;
 reg ptr u64[nlimbs] r;
 a = _bn_load_(ap);
 b = _bn_load_(bp);
 _cf, r = _bn_subc_(a, b);
 _bn_store_(rp, r);
}

export fn bn_muln(reg u64 rp ap bp) {
  reg u64 rp_; 
  stack u64[nlimbs] a b;
  stack u64[2*nlimbs] r;
  a = _bn_load_(ap);
  b = _bn_load_(bp);
  rp_ = rp; // relax ABI constraint
  r = _bn_muln_(a, b, r);
  _bn2_store_(rp_, r);
}

export fn bn_sqrn(reg u64 rp ap) {
  reg u64 rp_; 
  stack u64[nlimbs] a;
  stack u64[2*nlimbs] r;
  a = _bn_load_(ap);
  rp_ = rp; // relax ABI constraint
  r = _bn_sqrn_(a, r);
  _bn2_store_(rp_, r);
}

#endif
// end: BN_GENERIC_EXPORT

#ifdef BN_GENERIC_TOEC

inline fn toEC() {
  
}

#endif
// end: BN_GENERIC_TOEC

#endif
// end: JASMIN_BN_GENERIC
